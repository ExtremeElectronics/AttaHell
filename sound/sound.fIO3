
/**
 * https://github.com/ExtremeElectronics/pippestrelle
 *
 * sound.c
 *
 *
 * SPDX-License-Identifier: BSD-3-Clause
**/

#include <string.h>
#include "malloc.h"
#include "stdarg.h"
#include <stdio.h>
#include <stdlib.h>

//pico stuff
#include "pico/multicore.h"
#include "hardware/pwm.h"
#include "hardware/dma.h"
#include "hardware/gpio.h"

#include "sound.h"
#include "../settings.h"

#include "sample.c"

//sound buffer
const uint32_t * bufferptr = &BatSounds[0];

uint32_t dmafreq=9600; //dma timer frequency 

uint8_t old_mute=0;
uint8_t old_freq=0;

uint8_t mute=0;

uint8_t vmute=0;
uint8_t fmute=0;

extern float volume;
extern uint8_t wave; //wave shape selection ??? remove

uint PWMslice1;
uint PWMslice2;
uint PWMslice3;

const uint32_t trigg = 1; //The transaction count

//dma channels
int pwm_dma_chan1;
int pwm_dma_chan2;
int ctl_dma_chan; 

uint8_t old_ws,old_vol;
dma_channel_config ctl_dma_chan_config;
dma_channel_config pwm_dma_chan1_config;
dma_channel_config pwm_dma_chan2_config;

int ptimer ; //dma pacing timer

void SetPWM2(void){
    //setup PWM GPIO for 40khz tone
    gpio_init(soundIO3);
    gpio_set_dir(soundIO3,GPIO_OUT);
    gpio_set_function(soundIO3, GPIO_FUNC_PWM);

    gpio_init(soundIO4);
    gpio_set_dir(soundIO4,GPIO_OUT);
    gpio_set_function(soundIO4, GPIO_FUNC_PWM);

    //get slice from gpio pin
    PWMslice3=pwm_gpio_to_slice_num(soundIO3);

    //setup pwm
    pwm_set_clkdiv(PWMslice2,PICOCLOCK*1000/40000/256);//40khz
    pwm_set_both_levels(PWMslice3,128,128);
    pwm_set_output_polarity(PWMslice3,true,false);
    pwm_set_wrap (PWMslice3, 256);
    pwm_set_enabled(PWMslice3,true);

}

void PWMOn(int x){
   if (x){
     pwm_set_both_levels(PWMslice2,128,128);
   }else{
     pwm_set_both_levels(PWMslice2,0,0);
   }
}

void SetPWM(void){
    //setup PWM GPIO
    gpio_init(soundIO1);
    gpio_set_dir(soundIO1,GPIO_OUT);
    gpio_set_function(soundIO1, GPIO_FUNC_PWM);

    gpio_init(soundIO2);
    gpio_set_dir(soundIO2,GPIO_OUT);
    gpio_set_function(soundIO2, GPIO_FUNC_PWM);

    //get slice from gpio pin
    PWMslice1=pwm_gpio_to_slice_num(soundIO1);
    PWMslice2=pwm_gpio_to_slice_num(soundIO2);
 
    //setup pwm
    pwm_set_clkdiv(PWMslice1,1);//loads of mhz
    pwm_set_both_levels(PWMslice1,128,128);
    pwm_set_output_polarity(PWMslice1,false,true);
    pwm_set_wrap (PWMslice1, 256);
    pwm_set_enabled(PWMslice1,true);

    //setup inverted pwm
    pwm_set_clkdiv(PWMslice2,1);//loads of mhz
    pwm_set_both_levels(PWMslice2,128,128);
    pwm_set_output_polarity(PWMslice2,true,false);
    pwm_set_wrap (PWMslice2, 256);
    pwm_set_enabled(PWMslice2,true);

    //setup DMA
    // Setup DMA channel to drive the PWM
    pwm_dma_chan1 = dma_claim_unused_channel(true);
    pwm_dma_chan2 = dma_claim_unused_channel(true);
    
    // Setup DMA channel to control the DMA
//    ctl_dma_chan = dma_claim_unused_channel(true);

    //ctl chan config
//    ctl_dma_chan_config = dma_channel_get_default_config(ctl_dma_chan);
//    channel_config_set_transfer_data_size(&ctl_dma_chan_config, DMA_SIZE_32);
//    channel_config_set_read_increment(&ctl_dma_chan_config, false);
//    channel_config_set_write_increment(&ctl_dma_chan_config, false);

    // Setup the ctl channel 
//    dma_channel_configure(
//        ctl_dma_chan, &ctl_dma_chan_config,
//        &dma_hw->ch[pwm_dma_chan1].al3_read_addr_trig , //trigger reload the channel counter and start pwm_dma_chan
//        &bufferptr, // pointer to pointer start of buffer
//        1,
//        false // Dont Start.
//    );    

    //pwm channel config
    pwm_dma_chan1_config = dma_channel_get_default_config(pwm_dma_chan1);
    channel_config_set_transfer_data_size(&pwm_dma_chan1_config, DMA_SIZE_32);
    channel_config_set_read_increment(&pwm_dma_chan1_config, true);
    channel_config_set_write_increment(&pwm_dma_chan1_config, false);

    pwm_dma_chan2_config = dma_channel_get_default_config(pwm_dma_chan2);
    channel_config_set_transfer_data_size(&pwm_dma_chan2_config, DMA_SIZE_32);
    channel_config_set_read_increment(&pwm_dma_chan2_config, true);
    channel_config_set_write_increment(&pwm_dma_chan2_config, false);

    //dma dreq by timer  
    ptimer = dma_claim_unused_timer(true /* required */);
    dma_timer_set_fraction(ptimer, 1, 1000); //set starting clock as system clock /1000
    int treq = dma_get_timer_dreq(ptimer);

    channel_config_set_dreq(&pwm_dma_chan1_config, treq); //Select a transfer request signal. timer0??
    channel_config_set_dreq(&pwm_dma_chan2_config, treq);
    
    channel_config_set_chain_to(&pwm_dma_chan1_config, ctl_dma_chan); //When this channel completes, it will trigger ctl_dma_chan
    channel_config_set_chain_to(&pwm_dma_chan2_config, ctl_dma_chan); //When this channel completes, it will trigger ctl_dma_chan


    // Setup the PWM channel 
    dma_channel_configure(
        pwm_dma_chan1, &pwm_dma_chan1_config,
        &pwm_hw->slice[PWMslice].cc, // Write to PWM counter compare
        BatSounds, // Read values from waveshapes
        SAMPLESIZE, // no values to stream
        false // Dont Start.
    );
    //dma_start_channel_mask(1u << ctl_dma_chan); //Start control channel

    // Setup the PWM channel 
    dma_channel_configure(
        pwm_dma_chan2, &pwm_dma_chan2_config,
        &pwm_hw->slice[PWMslice2].cc, // Write to PWM counter compare
        BatSounds, // Read values from waveshapes
        SAMPLESIZE, // no values to stream
        false // Dont Start.
    );
    //dma_start_channel_mask(1u << ctl_dma_chan); //Start control channel
}

void startDMA(void){
//      printf("Start DMA Single\n");

//        hw_clear_bits(&dma_hw->ch[pwm_dma_chan].al1_ctrl, DMA_CH0_CTRL_TRIG_EN_BITS);
        hw_clear_bits(&dma_hw->ch[ctl_dma_chan].al1_ctrl, DMA_CH0_CTRL_TRIG_EN_BITS);
/*
        dma_channel_configure(
          ctl_dma_chan, &ctl_dma_chan_config,
          &dma_hw->ch[pwm_dma_chan].al3_read_addr_trig , //trigger reload the channel counter and start pwm_dma_chan
          &bufferptr, // pointer to pointer start of buffer
          1,
          true // Start.
        );
*/
        dma_channel_configure(
            pwm_dma_chan1, &pwm_dma_chan1_config,
            &pwm_hw->slice[PWMslice1].cc, // Write to PWM counter compare
            BatSounds, // Read values from waveshapes
            SAMPLESIZE, // no values to stream
            true // Dont Start.
        );
        dma_channel_configure(
            pwm_dma_chan2, &pwm_dma_chan2_config,
            &pwm_hw->slice[PWMslice2].cc, // Write to PWM counter compare
            BatSounds, // Read values from waveshapes
            SAMPLESIZE, // no values to stream
            true // Dont Start.
        );

        
        //dma_start_channel_mask(1u << pwm_dma_chan); //Start PWM channel

}


void init_sound(void){
    SetPWM();

//    uint32_t f=65000; 
//    uint32_t f=96000; 
//    uint32_t f=9600; 
    uint32_t f=FRAMERATE;
    printf("Set Rate %i\n",f);
    dmafreq=PICOCLOCK*1000/f;
//    dmafreq=PICOCLOCK/f;
    
    dma_timer_set_fraction(ptimer, 1, dmafreq);  // divide system clock by num/denomdma_timer_set_fraction(ptimer, 1, 400);  // divide system clock by num/denom 

    printf("Sound INIT Done\n");    
}


// DFA in core1
void Sound_Loop(void){
    while(1){
        sleep_us(100);
//        printf(".");
    }
}
